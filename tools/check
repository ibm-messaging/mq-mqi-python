#!/bin/bash

# This script does a bunch of consistency checks and test execution and should be
# run before a final commit and publish. Run it manually, so you can answer the questions

# Copyright (c) 2025 IBM Corporation. All Rights Reserved.

function cleanup {
  # The main $logFile is deliberately not deleted as we may need
  # to review it after execution.

  if [ -r $errFile ]
  then
     rm -f $errFile
  fi
}

function waitForEnter {
  if $isTty
  then
    echo
    read -p "Press ENTER to continue"  x
  fi
}

function continueYN {

  # Assume "Y" if not running interactively
  if ! $isTty
  then
    return 0
  fi

  prompt="$1"
  while true
  do
    read -p "$prompt? [Y/N] " yn
    case $yn in
    y*|Y*)
       #echo 0
       return 0
       ;;
    n*|N*)
      #echo 1
      return 1
      ;;
    *)
      ;;
    esac
  done
  return 0
}

function strucVer {
  # Prints a list (possibly empty) to stdout showing
  # diffs in the structure version numbers compared to the
  # public git repo version.
  git diff origin/main -- $src/code/ibmmq/*C*.py |\
    grep CURRENT_VERSION |\
    grep "^+" |\
    sort -u
}

function main {
curdir=`pwd`

errFile="/tmp/pyCheck.$$"
rm -f $errFile

src=$curdir/..

trap cleanup EXIT

echo
echo "Looking for version number consistency..."
cd $src
v=`grep "VERSION.*=.*[0-9]" setup.py | awk '{print $3}' | sed "s/'//g"`
echo "  Version in setup.py = $v"

echo 0 > $errFile

# This might be redundant since there should now be only a single place where the package
# version is defined. But I'll leave it for now, in case we ever do add other locations.
cd $src/code
find `pwd`  -type f |\
  grep -v ".*C.*\.py" |\
  grep -v "pyc$" |\
  grep -v "/tests/" |\
  grep -v "/examples/" |\
  grep -v "so$" |\
  grep -v "README$" |\
  grep -v "cache" |\
  grep -v "egg-info" |\
while read f
do
  (
  for major in 1 2
  do
  grep -qi "version.*$major\." $f
  if [ $? -eq 0 ]
  then
    # echo Looking in $f
    grep -q "$v" $f
    if [ $? -eq 0 ]
    then
      echo "  OK   : $f has same version number"
    else
      echo "  ERROR: $f does not have correct version"
      echo "1" > $errFile
    fi
  fi
  done
  ) | sort -u
done

if [ `cat $errFile` -eq 1 ]
then
  echo "Version checking failed"
  exit 1
fi

cd $src/code/examples
echo
echo "Looking for MQ VRMF info..."
cmdlevel=`grep MQCMDL_CURRENT_LEVEL ../ibmmq/CMQSTRC.py | awk '{print $3}' | sed "s/,//g"`
echo "  Command level in repo = $cmdlevel"

# The Dockerfile ought to be pointing at the most recent version. Whose Redist Client
# package needs to be available if we want the "runInContainer" test to pass. We make it
# a warning if the VRM does not match, not an error, to allow earlier test attempts to pass.
# Though we can point the container to download from a local server instead of public instead.
#
# No other files currently seem to have a VRMF dependency.
for f in Dockerfile
do
  vrmf=`grep "VRMF=" $f | cut -f2 -d" " | cut -f2 -d=`
  if [ -z "$vrmf" ]
  then
    echo "  ERROR: Cannot find VRMF in $f"
    exit 1
  fi

  vrm=`echo $vrmf | awk '{
         split($1,a,".")
         printf("%d%d%d\n",a[1],a[2],a[3])
       }
     '`

  if [ "$vrm" != "$cmdlevel" ]
  then
    echo "  WARN : VRMF $vrmf [$vrm] does not match CMDLEVEL $cmdlevel in $f"
  else
    echo "  OK   : Example $f building on MQ $vrmf"
  fi
done

cd $src/code/ibmmq
echo
echo "Looking for debug lines to remove..."

(
# There's a print() in the debug dumper that we need to ignore
# Assume there's a space between any comment char and the next token
find . -name "*.py" -type f | xargs grep "print(" |\
   grep -v getattr |\
   awk '{
           if ($2 != "#") {
             print $0
           }
         }'

# find . -name "*.py" -type f | xargs grep log

find . -name "*.c" -type f | xargs grep printf | grep -v snprintf
) | tee $errFile
cnt=`cat $errFile | wc -l `
if [ $cnt -ne 0 ]
then
  echo "  WARN : Debug printing may need removal"
  # exit 1
else
  echo "  OK   : No debug lines found"
fi


# Confirm structure/class ersions have been dealt with
echo
echo "Checking structure updates"
cnt=`strucVer | wc -l`
if [ $cnt -eq 0 ]
then
  echo "  OK  : No structure updates needed"
else
  # Look in the source files to see if we have actually incorporated
  # the new structure version. We build a grep line that checks for something like
  #  "if gmo_current_version >= CMQC.MQGMO_VERSION_4"
  # which assumes we've used that pattern for all the class definitions. But we have!
  strucVer |  sed "s/^\+/  /g" | while read line
  do
    strucC=`echo $line | cut -f1 -d_ `
    strucPy=`echo $strucC| sed "s/MQ//g" | tr '[:upper:]' '[:lower:]' `
    ver=`echo $line | cut -f3 -d" "`
        ver=3

    echo "  Checking $strucPy "

    srch=`printf "if %s_current_version >= CMQC.%s_VERSION_%d" $strucPy $strucC $ver`
    grep -q "$srch" $src/code/ibmmq/mq*py
    if [ $? -ne 0 ]
    then
      echo "  ERROR: Missing $line"
    else
      echo "  OK   : Found $line"
    fi
  done

  #strucVer | sed "s/^\+/  /g"
  #continueYN "Confirm structures have been updated"
  #if [ $? -ne 0 ]
  #then
  #  echo "  ERROR : Need to go back to fix updated/new structures before continuing"
  #  exit 1
  #fi
fi

# Try building against an old level of MQ
if [ -x $curdir/checkOld ]
then
  echo
  continueYN "Build against an old level of MQ"
  if [ $? -eq 0 ]
  then
    cd $curdir
    checkOld
    if [ $? -ne 0 ]
    then
      echo " ERROR : Problem running old level build"
      exit 1
    fi
  fi
fi

# Give a chance to quit now, before spending a lot of time on tests
if [ -x $curdir/checkRemote ]
then
  echo
  continueYN "Run BVT on remote machines"
  if [ $? -eq 0 ]
  then
    cd $curdir
    checkRemote
    if [ $? -ne 0 ]
    then
      echo " ERROR : Problem running remote system check"
      exit 1
    fi
  fi
fi

echo
continueYN "Continue to run unit tests"
if [ $? -eq 0 ]
then
  echo "Running all testcases..."
  cd $src/code/tests
  ./runContainer.sh
  ./runAllTests.sh
fi

echo
continueYN "Continue to run examples"
if [ $? -eq 0 ]
then
  echo "Running all examples..."
  cd $curdir
  # Strip a specific queuename so it doesn't cause problems with the final step.
  ./runAllExamples < /dev//null 2>&1|\
     grep -av "SYSTEM.PROTECTION.ERROR.QUEUE"
fi

}

#########################################
# Script starts executing here
#########################################
logFile=/tmp/pyCheck.log

tty -s
if [ $? -eq 0 ]
then
  isTty=true
else
  isTty=false
fi

# Run the main code.

main 2>&1 |\
   tee $logFile

echo
echo "---------------------"
grep -aq -E "WARN|ERR" $logFile
if [ $? -eq 0 ]
then
  echo
  echo "ERROR: Checking process has a problem."
  exit 1
fi

echo "Checking process has completed OK"
exit 0
